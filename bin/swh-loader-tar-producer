#!/usr/bin/env python3

# Copyright (C) 2015  The Software Heritage developers
# See the AUTHORS file at the top-level directory of this distribution
# License: GNU General Public License version 3, or any later version
# See top-level LICENSE file for more information

import sys
import os

from swh.core import config
from swh.loader.tar import tasks, tarball, build


def list_archives_from(path):
    """From path, produce archive tarball message to celery.

    Args:
        path: top directory to list archives from.

    """
    for dirpath, dirnames, filenames in os.walk(path):
        for fname in filenames:
            tarpath = os.path.join(dirpath, fname)
            if not os.path.exists(tarpath):
                continue

            tarball_nature = tarball.nature(tarpath)
            if not tarball_nature:
                continue

            yield tarball.Tarball(tarball_nature, fname, tarpath)


def compute_message_from(conf, root_dir, tarball):
    """Post the message to workers.

    Args:
        conf: dictionary holding static metadata
        root_dir: root directory
        tarball: the archive's representation

    Returns:
        None

    """
    tarpath = tarball.path
    filename = tarball.name
    origin = build.compute_origin(conf['url_scheme'],
                                  conf['type'],
                                  root_dir,
                                  tarpath)
    revision = build.compute_revision()
    occurrences = [build.gnu_occurrence(tarpath),
                   build.swh_occurrence(tarpath)]
    release = build.compute_release(filename, tarpath)

    task = tasks.LoadTarRepository()
    task.apply_async((tarball.to_dict(),
                      origin,
                      revision,
                      release,
                      occurrences))


def produce_archive_messages_from(conf, path):
    """From path, produce archive tarball message to celery.

    Args:
        conf: dictionary holding static metadata
        path: top directory to list archives from.

    Returns:
        None

    """
    LIMIT = conf['limit']
    count = 0

    for archive in list_archives_from(path):
        count += 1
        compute_message_from(conf, path, archive)
        if LIMIT and count >= LIMIT:
            return count

    return count


def load_config(conf_file):
    """Load the configuration from file.

    """
    conf = config.read(conf_file,
                       default_conf={'limit': ('int', None)})
    url_scheme = conf['url_scheme']
    mirror_dir = conf['mirror_root_directory']

    # remove trailing / in configuration (to ease ulterior computation)
    if url_scheme[-1] == '/':
        conf.update({
            'url_scheme': url_scheme[0:-1]
        })

    if mirror_dir[-1] == '/':
        conf.update({
            'mirror_root_directory': mirror_dir[0:-1]
        })

    return conf


if __name__ == '__main__':
    conf_file = sys.argv[1]
    if not os.path.exists(conf_file):
        conf_file = '../resources/producer/tar.ini'

    conf = load_config(conf_file)

    root_dir = conf['mirror_root_directory'].encode('utf-8')

    nb_tarballs = produce_archive_messages_from(conf, root_dir)
