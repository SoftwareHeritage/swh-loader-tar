#!/usr/bin/env python3

# Copyright (C) 2015  The Software Heritage developers
# See the AUTHORS file at the top-level directory of this distribution
# License: GNU General Public License version 3, or any later version
# See top-level LICENSE file for more information

import argparse
import os
import sys

from swh.core import config
from swh.loader.tar import tasks, tarball, build


def list_archives_from(path):
    """From path, produce archive tarball message to celery.

    Args:
        path: top directory to list archives from.

    """
    for dirpath, dirnames, filenames in os.walk(path):
        for fname in filenames:
            tarpath = os.path.join(dirpath, fname)
            if not os.path.exists(tarpath):
                continue

            if tarball.is_tarball(tarpath):
                yield tarpath, fname


def compute_message_from(conf, root_dir, tarpath, filename, dry_run=False):
    """Compute and post the message to worker for the archive tarpath.

    Args:
        conf: dictionary holding static metadata
        root_dir: root directory
        tarball: the archive's representation
        dry_run: will compute but not send messages

    Returns:
        None

    Raises:
        ValueError when release number computation error arise.

    """
    origin = build.compute_origin(conf['url_scheme'],
                                  conf['type'],
                                  root_dir,
                                  tarpath)
    revision = build.compute_revision()
    occurrences = [build.gnu_occurrence(tarpath),
                   build.swh_occurrence(tarpath)]
    release = build.compute_release(filename, tarpath)

    if not dry_run:
        task = tasks.LoadTarRepository()
        task.apply_async((tarpath,
                          origin,
                          revision,
                          release,
                          occurrences))


def produce_archive_messages_from(conf, path, dry_run=False):
    """From path, produce archive tarball messages to celery.

    Will print error message when some computation arise on archive
    and continue.

    Args:
        conf: dictionary holding static metadata
        path: top directory to list archives from.
        dry_run: will compute but not send messages

    Returns:
        None

    Raises:
        None

    """
    LIMIT = conf['limit']
    count = 0

    for tarpath, fname in list_archives_from(path):
        count += 1
        try:
            compute_message_from(conf, path, tarpath, fname, dry_run)
        except ValueError:
            print('Problem with the following archive: %s' % tarpath)

        if LIMIT and count >= LIMIT:
            return count

    return count


def load_config(conf_file):
    """Load the configuration from file.

    Args:
        conf_file: path to a configuration file with the following content:
        [main]

        # mirror's root directory holding tarballs to load into swh
        mirror_root_directory = /home/storage/space/mirrors/gnu.org/gnu/

        # origin setup's possible scheme url
        url_scheme = rsync://ftp.gnu.org/gnu/

        # origin type used for those tarballs
        type = ftp

        # For tryouts purposes (no limit if not specified)
        limit = 1

    Returns:
        dictionary of data present in the configuration file.


    """
    conf = config.read(conf_file,
                       default_conf={'limit': ('int', None)})
    url_scheme = conf['url_scheme']
    mirror_dir = conf['mirror_root_directory']

    # remove trailing / in configuration (to ease ulterior computation)
    if url_scheme[-1] == '/':
        conf.update({
            'url_scheme': url_scheme[0:-1]
        })

    if mirror_dir[-1] == '/':
        conf.update({
            'mirror_root_directory': mirror_dir[0:-1]
        })

    return conf


def parse_args():
    """Parse the configuration from the cli.

    """
    cli = argparse.ArgumentParser(
        description='Tarball producer of local fs tarballs.')
    cli.add_argument('--dry-run', '-n',
                     action='store_true',
                     help='Dry run (print repo only)')
    cli.add_argument('--config', '-c', help='configuration file path')

    args = cli.parse_args()

    return args


if __name__ == '__main__':
    args = parse_args()
    config_file = args.config
    if not config_file:
        print('Missing configuration file option.')
        sys.exit(1)

    conf = load_config(config_file)

    nb_tarballs = produce_archive_messages_from(conf,
                                                conf['mirror_root_directory'],
                                                args.dry_run)
