#!/usr/bin/env python3

# NOT FOR PRODUCTION (does not use the stable swh storage api yet)

# Copyright (C) 2015  The Software Heritage developers
# See the AUTHORS file at the top-level directory of this distribution
# License: GNU General Public License version 3, or any later version
# See top-level LICENSE file for more information

import argparse
import os
import shutil
import sys
import tempfile

from swh.core import hashutil, config
from swh.loader.tar import tarball


def escape_hash(sha1):
    """Escape an hexa sha1 to a ready queryable sha1."""
    if isinstance(sha1, bytes):
        sha1 = hashutil.hash_to_hex(sha1)
    return '\\x%s' % sha1


def upper_directory_from(revision_id):
    """Return the directory sha1 the revision with id revision_id points to.

    """
    for revision in storage.revision_get([revision_id]):
        return revision['directory']


def directory_ls_with_content(directory_id, recursive=True):
    """List directories with their data when content targeted is a file.

    """
    for entry in storage.directory_get(directory_id, recursive=recursive):
        entry['name'] = entry['name'].decode('utf-8')
        if entry['type'] == 'dir':
            yield entry
        else:
            sha1 = entry['sha1']
            status = entry['status']

            # HACK: heavy, 1 post per content, need to batch
            contents_data = list(storage.content_get(
                [{'sha1': sha1, 'status': status}]))
            entry['data'] = contents_data[0]['data']

            yield entry


def build_archive_from_revision(archive_type, tarpath, revision_id):
    directory_id = upper_directory_from(revision_id)
    print('directory id: %s' % hashutil.hash_to_hex(directory_id))

    # build fs structure
    tmpdir = tempfile.mkdtemp(suffix='create-tarball',
                              prefix='swh.loader.tar',
                              dir='/tmp')

    count = 0
    for entry in directory_ls_with_content(directory_id, recursive=True):
        name = entry['name']
        perms = entry['perms']

        path = os.path.join(tmpdir, name)

        if perms == 40000:  # dir
            os.makedirs(path, exist_ok=True)
            os.chmod(path, 0o755)
        elif perms == 100644:  # file
            dirpath = os.path.dirname(path)
            os.makedirs(dirpath, exist_ok=True)
            os.chmod(dirpath, 0o755)

            file_content = entry['data']
            with open(path, 'wb') as f:
                f.write(file_content)

            os.chmod(path, 0o644)
        else:  # symlink
            linkdest = entry['data']
            os.symlink(path, linkdest)

        print(perms, path)
        count += 1

    print('%s entries' % count)

    # build archive from the tree
    print('Compressing archive %s ' % tarpath)
    tarball.compress(tarpath, tmpdir, archive_type)

    # clean up tmp directory
    shutil.rmtree(tmpdir)

    return tarpath


def parse_args():
    """Parse the configuration from the cli.

    """
    cli = argparse.ArgumentParser(
        description='Tarball creation from swh-storage.')
    cli.add_argument('--config-file', '-c', help='configuration file')
    cli.add_argument('--type-archive', '-t',
                     default='tar',
                     help='archive type (zip or tar)')
    cli.add_argument('--file-path', '-f',
                     help='configuration file path')
    cli.add_argument('--revision', '-r',
                     help='revision checksum')

    args = cli.parse_args()

    return args


def check_args(args):
    """Check cli args and returns the error msg.

    Returns:
        List of error messages as string if some.

    """
    errorMsgs = []
    if not args.config_file:
        errorMsgs.append('\n- Configuration file option.')

    if not args.file_path:
        errorMsgs.append('\n- File path to archive')

    if not args.revision:
        errorMsgs.append('\n- Revision checksum')

    return errorMsgs


if __name__ == '__main__':
    args = parse_args()

    errorMsgs = check_args(args)
    if errorMsgs:
        print('Some mandatory options are missing: %s' % ''.join(errorMsgs))
        sys.exit(1)

    conf = config.read(args.config_file)
    type_archive = args.type_archive
    tarpath = args.file_path
    revision_hex = args.revision

    if conf['storage_class'] == 'remote_storage':
        from swh.storage.api.client import RemoteStorage as Storage
    else:
        from swh.storage import Storage

    storage = Storage(conf['storage_args'])

    revision_id = hashutil.hex_to_hash(revision_hex)
    build_archive_from_revision(type_archive, tarpath, revision_id)
